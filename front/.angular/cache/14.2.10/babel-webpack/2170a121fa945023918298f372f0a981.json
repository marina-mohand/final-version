{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, forwardRef, EventEmitter, Directive, Output, Input, ContentChildren, ViewChild, Component, ViewEncapsulation, ChangeDetectionStrategy, Optional, Inject, Attribute, NgModule } from '@angular/core';\nimport * as i3 from '@angular/material/core';\nimport { mixinDisableRipple, mixinTabIndex, MatRippleModule, MatCommonModule } from '@angular/material/core';\nimport * as i1 from '@angular/cdk/a11y';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport * as i2 from '@angular/cdk/collections';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\nconst _c0 = [\"input\"];\n\nconst _c1 = function (a0) {\n  return {\n    enterDuration: a0\n  };\n};\n\nconst _c2 = [\"*\"];\nconst MAT_RADIO_DEFAULT_OPTIONS = new InjectionToken('mat-radio-default-options', {\n  providedIn: 'root',\n  factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY\n});\n\nfunction MAT_RADIO_DEFAULT_OPTIONS_FACTORY() {\n  return {\n    color: 'accent'\n  };\n} // Increasing integer for generating unique ids for radio components.\n\n\nlet nextUniqueId = 0;\n/**\r\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\r\n * allows it to support [(ngModel)] and ngControl.\r\n * @docs-private\r\n */\n\nconst MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatRadioGroup),\n  multi: true\n};\n/** Change event object emitted by MatRadio and MatRadioGroup. */\n\nclass MatRadioChange {\n  constructor(\n  /** The MatRadioButton that emits the change event. */\n  source,\n  /** The value of the MatRadioButton. */\n  value) {\n    this.source = source;\n    this.value = value;\n  }\n\n}\n/**\r\n * Injection token that can be used to inject instances of `MatRadioGroup`. It serves as\r\n * alternative token to the actual `MatRadioGroup` class which could cause unnecessary\r\n * retention of the class and its component metadata.\r\n */\n\n\nconst MAT_RADIO_GROUP = new InjectionToken('MatRadioGroup');\n/**\r\n * Base class with all of the `MatRadioGroup` functionality.\r\n * @docs-private\r\n */\n\nclass _MatRadioGroupBase {\n  constructor(_changeDetector) {\n    this._changeDetector = _changeDetector;\n    /** Selected value for the radio group. */\n\n    this._value = null;\n    /** The HTML name attribute applied to radio buttons in this group. */\n\n    this._name = `mat-radio-group-${nextUniqueId++}`;\n    /** The currently selected radio button. Should match value. */\n\n    this._selected = null;\n    /** Whether the `value` has been set to its initial value. */\n\n    this._isInitialized = false;\n    /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n\n    this._labelPosition = 'after';\n    /** Whether the radio group is disabled. */\n\n    this._disabled = false;\n    /** Whether the radio group is required. */\n\n    this._required = false;\n    /** The method to be called in order to update ngModel */\n\n    this._controlValueAccessorChangeFn = () => {};\n    /**\r\n     * onTouch function registered via registerOnTouch (ControlValueAccessor).\r\n     * @docs-private\r\n     */\n\n\n    this.onTouched = () => {};\n    /**\r\n     * Event emitted when the group value changes.\r\n     * Change events are only emitted when the value changes due to user interaction with\r\n     * a radio button (the same behavior as `<input type-\"radio\">`).\r\n     */\n\n\n    this.change = new EventEmitter();\n  }\n  /** Name of the radio button group. All radio buttons inside this group will use this name. */\n\n\n  get name() {\n    return this._name;\n  }\n\n  set name(value) {\n    this._name = value;\n\n    this._updateRadioButtonNames();\n  }\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n\n\n  get labelPosition() {\n    return this._labelPosition;\n  }\n\n  set labelPosition(v) {\n    this._labelPosition = v === 'before' ? 'before' : 'after';\n\n    this._markRadiosForCheck();\n  }\n  /**\r\n   * Value for the radio-group. Should equal the value of the selected radio button if there is\r\n   * a corresponding radio button with a matching value. If there is not such a corresponding\r\n   * radio button, this value persists to be applied in case a new radio button is added with a\r\n   * matching value.\r\n   */\n\n\n  get value() {\n    return this._value;\n  }\n\n  set value(newValue) {\n    if (this._value !== newValue) {\n      // Set this before proceeding to ensure no circular loop occurs with selection.\n      this._value = newValue;\n\n      this._updateSelectedRadioFromValue();\n\n      this._checkSelectedRadioButton();\n    }\n  }\n\n  _checkSelectedRadioButton() {\n    if (this._selected && !this._selected.checked) {\n      this._selected.checked = true;\n    }\n  }\n  /**\r\n   * The currently selected radio button. If set to a new radio button, the radio group value\r\n   * will be updated to match the new selected button.\r\n   */\n\n\n  get selected() {\n    return this._selected;\n  }\n\n  set selected(selected) {\n    this._selected = selected;\n    this.value = selected ? selected.value : null;\n\n    this._checkSelectedRadioButton();\n  }\n  /** Whether the radio group is disabled */\n\n\n  get disabled() {\n    return this._disabled;\n  }\n\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n\n    this._markRadiosForCheck();\n  }\n  /** Whether the radio group is required */\n\n\n  get required() {\n    return this._required;\n  }\n\n  set required(value) {\n    this._required = coerceBooleanProperty(value);\n\n    this._markRadiosForCheck();\n  }\n  /**\r\n   * Initialize properties once content children are available.\r\n   * This allows us to propagate relevant attributes to associated buttons.\r\n   */\n\n\n  ngAfterContentInit() {\n    // Mark this component as initialized in AfterContentInit because the initial value can\n    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n    // NgModel occurs *after* the OnInit of the MatRadioGroup.\n    this._isInitialized = true;\n  }\n  /**\r\n   * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\r\n   * radio buttons upon their blur.\r\n   */\n\n\n  _touch() {\n    if (this.onTouched) {\n      this.onTouched();\n    }\n  }\n\n  _updateRadioButtonNames() {\n    if (this._radios) {\n      this._radios.forEach(radio => {\n        radio.name = this.name;\n\n        radio._markForCheck();\n      });\n    }\n  }\n  /** Updates the `selected` radio button from the internal _value state. */\n\n\n  _updateSelectedRadioFromValue() {\n    // If the value already matches the selected radio, do nothing.\n    const isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n\n    if (this._radios && !isAlreadySelected) {\n      this._selected = null;\n\n      this._radios.forEach(radio => {\n        radio.checked = this.value === radio.value;\n\n        if (radio.checked) {\n          this._selected = radio;\n        }\n      });\n    }\n  }\n  /** Dispatch change event with current selection and group value. */\n\n\n  _emitChangeEvent() {\n    if (this._isInitialized) {\n      this.change.emit(new MatRadioChange(this._selected, this._value));\n    }\n  }\n\n  _markRadiosForCheck() {\n    if (this._radios) {\n      this._radios.forEach(radio => radio._markForCheck());\n    }\n  }\n  /**\r\n   * Sets the model value. Implemented as part of ControlValueAccessor.\r\n   * @param value\r\n   */\n\n\n  writeValue(value) {\n    this.value = value;\n\n    this._changeDetector.markForCheck();\n  }\n  /**\r\n   * Registers a callback to be triggered when the model value changes.\r\n   * Implemented as part of ControlValueAccessor.\r\n   * @param fn Callback to be registered.\r\n   */\n\n\n  registerOnChange(fn) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n  /**\r\n   * Registers a callback to be triggered when the control is touched.\r\n   * Implemented as part of ControlValueAccessor.\r\n   * @param fn Callback to be registered.\r\n   */\n\n\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n  /**\r\n   * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\r\n   * @param isDisabled Whether the control should be disabled.\r\n   */\n\n\n  setDisabledState(isDisabled) {\n    this.disabled = isDisabled;\n\n    this._changeDetector.markForCheck();\n  }\n\n}\n\n_MatRadioGroupBase.ɵfac = function _MatRadioGroupBase_Factory(t) {\n  return new (t || _MatRadioGroupBase)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n};\n\n_MatRadioGroupBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: _MatRadioGroupBase,\n  inputs: {\n    color: \"color\",\n    name: \"name\",\n    labelPosition: \"labelPosition\",\n    value: \"value\",\n    selected: \"selected\",\n    disabled: \"disabled\",\n    required: \"required\"\n  },\n  outputs: {\n    change: \"change\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(_MatRadioGroupBase, [{\n    type: Directive\n  }], function () {\n    return [{\n      type: i0.ChangeDetectorRef\n    }];\n  }, {\n    change: [{\n      type: Output\n    }],\n    color: [{\n      type: Input\n    }],\n    name: [{\n      type: Input\n    }],\n    labelPosition: [{\n      type: Input\n    }],\n    value: [{\n      type: Input\n    }],\n    selected: [{\n      type: Input\n    }],\n    disabled: [{\n      type: Input\n    }],\n    required: [{\n      type: Input\n    }]\n  });\n})();\n/**\r\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\r\n */\n\n\nclass MatRadioGroup extends _MatRadioGroupBase {}\n\nMatRadioGroup.ɵfac = /* @__PURE__ */function () {\n  let ɵMatRadioGroup_BaseFactory;\n  return function MatRadioGroup_Factory(t) {\n    return (ɵMatRadioGroup_BaseFactory || (ɵMatRadioGroup_BaseFactory = i0.ɵɵgetInheritedFactory(MatRadioGroup)))(t || MatRadioGroup);\n  };\n}();\n\nMatRadioGroup.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MatRadioGroup,\n  selectors: [[\"mat-radio-group\"]],\n  contentQueries: function MatRadioGroup_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      i0.ɵɵcontentQuery(dirIndex, MatRadioButton, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._radios = _t);\n    }\n  },\n  hostAttrs: [\"role\", \"radiogroup\", 1, \"mat-radio-group\"],\n  exportAs: [\"matRadioGroup\"],\n  features: [i0.ɵɵProvidersFeature([MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, {\n    provide: MAT_RADIO_GROUP,\n    useExisting: MatRadioGroup\n  }]), i0.ɵɵInheritDefinitionFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MatRadioGroup, [{\n    type: Directive,\n    args: [{\n      selector: 'mat-radio-group',\n      exportAs: 'matRadioGroup',\n      providers: [MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, {\n        provide: MAT_RADIO_GROUP,\n        useExisting: MatRadioGroup\n      }],\n      host: {\n        'role': 'radiogroup',\n        'class': 'mat-radio-group'\n      }\n    }]\n  }], null, {\n    _radios: [{\n      type: ContentChildren,\n      args: [forwardRef(() => MatRadioButton), {\n        descendants: true\n      }]\n    }]\n  });\n})(); // Boilerplate for applying mixins to MatRadioButton.\n\n/** @docs-private */\n\n\nclass MatRadioButtonBase {\n  constructor(_elementRef) {\n    this._elementRef = _elementRef;\n  }\n\n}\n\nconst _MatRadioButtonMixinBase = mixinDisableRipple(mixinTabIndex(MatRadioButtonBase));\n/**\r\n * Base class with all of the `MatRadioButton` functionality.\r\n * @docs-private\r\n */\n\n\nclass _MatRadioButtonBase extends _MatRadioButtonMixinBase {\n  constructor(radioGroup, elementRef, _changeDetector, _focusMonitor, _radioDispatcher, animationMode, _providerOverride, tabIndex) {\n    super(elementRef);\n    this._changeDetector = _changeDetector;\n    this._focusMonitor = _focusMonitor;\n    this._radioDispatcher = _radioDispatcher;\n    this._providerOverride = _providerOverride;\n    this._uniqueId = `mat-radio-${++nextUniqueId}`;\n    /** The unique ID for the radio button. */\n\n    this.id = this._uniqueId;\n    /**\r\n     * Event emitted when the checked state of this radio button changes.\r\n     * Change events are only emitted when the value changes due to user interaction with\r\n     * the radio button (the same behavior as `<input type-\"radio\">`).\r\n     */\n\n    this.change = new EventEmitter();\n    /** Whether this radio is checked. */\n\n    this._checked = false;\n    /** Value assigned to this radio. */\n\n    this._value = null;\n    /** Unregister function for _radioDispatcher */\n\n    this._removeUniqueSelectionListener = () => {}; // Assertions. Ideally these should be stripped out by the compiler.\n    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n\n\n    this.radioGroup = radioGroup;\n    this._noopAnimations = animationMode === 'NoopAnimations';\n\n    if (tabIndex) {\n      this.tabIndex = coerceNumberProperty(tabIndex, 0);\n    }\n\n    this._removeUniqueSelectionListener = _radioDispatcher.listen((id, name) => {\n      if (id !== this.id && name === this.name) {\n        this.checked = false;\n      }\n    });\n  }\n  /** Whether this radio button is checked. */\n\n\n  get checked() {\n    return this._checked;\n  }\n\n  set checked(value) {\n    const newCheckedState = coerceBooleanProperty(value);\n\n    if (this._checked !== newCheckedState) {\n      this._checked = newCheckedState;\n\n      if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n        this.radioGroup.selected = this;\n      } else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n        // When unchecking the selected radio button, update the selected radio\n        // property on the group.\n        this.radioGroup.selected = null;\n      }\n\n      if (newCheckedState) {\n        // Notify all radio buttons with the same name to un-check.\n        this._radioDispatcher.notify(this.id, this.name);\n      }\n\n      this._changeDetector.markForCheck();\n    }\n  }\n  /** The value of this radio button. */\n\n\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    if (this._value !== value) {\n      this._value = value;\n\n      if (this.radioGroup !== null) {\n        if (!this.checked) {\n          // Update checked when the value changed to match the radio group's value\n          this.checked = this.radioGroup.value === value;\n        }\n\n        if (this.checked) {\n          this.radioGroup.selected = this;\n        }\n      }\n    }\n  }\n  /** Whether the label should appear after or before the radio button. Defaults to 'after' */\n\n\n  get labelPosition() {\n    return this._labelPosition || this.radioGroup && this.radioGroup.labelPosition || 'after';\n  }\n\n  set labelPosition(value) {\n    this._labelPosition = value;\n  }\n  /** Whether the radio button is disabled. */\n\n\n  get disabled() {\n    return this._disabled || this.radioGroup !== null && this.radioGroup.disabled;\n  }\n\n  set disabled(value) {\n    this._setDisabled(coerceBooleanProperty(value));\n  }\n  /** Whether the radio button is required. */\n\n\n  get required() {\n    return this._required || this.radioGroup && this.radioGroup.required;\n  }\n\n  set required(value) {\n    this._required = coerceBooleanProperty(value);\n  }\n  /** Theme color of the radio button. */\n\n\n  get color() {\n    // As per Material design specifications the selection control radio should use the accent color\n    // palette by default. https://material.io/guidelines/components/selection-controls.html\n    return this._color || this.radioGroup && this.radioGroup.color || this._providerOverride && this._providerOverride.color || 'accent';\n  }\n\n  set color(newValue) {\n    this._color = newValue;\n  }\n  /** ID of the native input element inside `<mat-radio-button>` */\n\n\n  get inputId() {\n    return `${this.id || this._uniqueId}-input`;\n  }\n  /** Focuses the radio button. */\n\n\n  focus(options, origin) {\n    if (origin) {\n      this._focusMonitor.focusVia(this._inputElement, origin, options);\n    } else {\n      this._inputElement.nativeElement.focus(options);\n    }\n  }\n  /**\r\n   * Marks the radio button as needing checking for change detection.\r\n   * This method is exposed because the parent radio group will directly\r\n   * update bound properties of the radio button.\r\n   */\n\n\n  _markForCheck() {\n    // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n    // update radio button's status\n    this._changeDetector.markForCheck();\n  }\n\n  ngOnInit() {\n    if (this.radioGroup) {\n      // If the radio is inside a radio group, determine if it should be checked\n      this.checked = this.radioGroup.value === this._value;\n\n      if (this.checked) {\n        this.radioGroup.selected = this;\n      } // Copy name from parent radio group\n\n\n      this.name = this.radioGroup.name;\n    }\n  }\n\n  ngAfterViewInit() {\n    this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n      if (!focusOrigin && this.radioGroup) {\n        this.radioGroup._touch();\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n\n    this._removeUniqueSelectionListener();\n  }\n  /** Dispatch change event with current value. */\n\n\n  _emitChangeEvent() {\n    this.change.emit(new MatRadioChange(this, this._value));\n  }\n\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n\n  _onInputClick(event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `radio-button` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n  }\n  /** Triggered when the radio button receives an interaction from the user. */\n\n\n  _onInputInteraction(event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n\n    if (!this.checked && !this.disabled) {\n      const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n      this.checked = true;\n\n      this._emitChangeEvent();\n\n      if (this.radioGroup) {\n        this.radioGroup._controlValueAccessorChangeFn(this.value);\n\n        if (groupValueChanged) {\n          this.radioGroup._emitChangeEvent();\n        }\n      }\n    }\n  }\n  /** Sets the disabled state and marks for check if a change occurred. */\n\n\n  _setDisabled(value) {\n    if (this._disabled !== value) {\n      this._disabled = value;\n\n      this._changeDetector.markForCheck();\n    }\n  }\n\n}\n\n_MatRadioButtonBase.ɵfac = function _MatRadioButtonBase_Factory(t) {\n  i0.ɵɵinvalidFactory();\n};\n\n_MatRadioButtonBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: _MatRadioButtonBase,\n  viewQuery: function _MatRadioButtonBase_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._inputElement = _t.first);\n    }\n  },\n  inputs: {\n    id: \"id\",\n    name: \"name\",\n    ariaLabel: [\"aria-label\", \"ariaLabel\"],\n    ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"],\n    ariaDescribedby: [\"aria-describedby\", \"ariaDescribedby\"],\n    checked: \"checked\",\n    value: \"value\",\n    labelPosition: \"labelPosition\",\n    disabled: \"disabled\",\n    required: \"required\",\n    color: \"color\"\n  },\n  outputs: {\n    change: \"change\"\n  },\n  features: [i0.ɵɵInheritDefinitionFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(_MatRadioButtonBase, [{\n    type: Directive\n  }], function () {\n    return [{\n      type: _MatRadioGroupBase\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i1.FocusMonitor\n    }, {\n      type: i2.UniqueSelectionDispatcher\n    }, {\n      type: undefined\n    }, {\n      type: undefined\n    }, {\n      type: undefined\n    }];\n  }, {\n    id: [{\n      type: Input\n    }],\n    name: [{\n      type: Input\n    }],\n    ariaLabel: [{\n      type: Input,\n      args: ['aria-label']\n    }],\n    ariaLabelledby: [{\n      type: Input,\n      args: ['aria-labelledby']\n    }],\n    ariaDescribedby: [{\n      type: Input,\n      args: ['aria-describedby']\n    }],\n    checked: [{\n      type: Input\n    }],\n    value: [{\n      type: Input\n    }],\n    labelPosition: [{\n      type: Input\n    }],\n    disabled: [{\n      type: Input\n    }],\n    required: [{\n      type: Input\n    }],\n    color: [{\n      type: Input\n    }],\n    change: [{\n      type: Output\n    }],\n    _inputElement: [{\n      type: ViewChild,\n      args: ['input']\n    }]\n  });\n})();\n/**\r\n * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.\r\n */\n\n\nclass MatRadioButton extends _MatRadioButtonBase {\n  constructor(radioGroup, elementRef, changeDetector, focusMonitor, radioDispatcher, animationMode, providerOverride, tabIndex) {\n    super(radioGroup, elementRef, changeDetector, focusMonitor, radioDispatcher, animationMode, providerOverride, tabIndex);\n  }\n\n}\n\nMatRadioButton.ɵfac = function MatRadioButton_Factory(t) {\n  return new (t || MatRadioButton)(i0.ɵɵdirectiveInject(MAT_RADIO_GROUP, 8), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.FocusMonitor), i0.ɵɵdirectiveInject(i2.UniqueSelectionDispatcher), i0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8), i0.ɵɵdirectiveInject(MAT_RADIO_DEFAULT_OPTIONS, 8), i0.ɵɵinjectAttribute('tabindex'));\n};\n\nMatRadioButton.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: MatRadioButton,\n  selectors: [[\"mat-radio-button\"]],\n  hostAttrs: [1, \"mat-radio-button\"],\n  hostVars: 17,\n  hostBindings: function MatRadioButton_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"focus\", function MatRadioButton_focus_HostBindingHandler() {\n        return ctx._inputElement.nativeElement.focus();\n      });\n    }\n\n    if (rf & 2) {\n      i0.ɵɵattribute(\"tabindex\", null)(\"id\", ctx.id)(\"aria-label\", null)(\"aria-labelledby\", null)(\"aria-describedby\", null);\n      i0.ɵɵclassProp(\"mat-radio-checked\", ctx.checked)(\"mat-radio-disabled\", ctx.disabled)(\"_mat-animation-noopable\", ctx._noopAnimations)(\"mat-primary\", ctx.color === \"primary\")(\"mat-accent\", ctx.color === \"accent\")(\"mat-warn\", ctx.color === \"warn\");\n    }\n  },\n  inputs: {\n    disableRipple: \"disableRipple\",\n    tabIndex: \"tabIndex\"\n  },\n  exportAs: [\"matRadioButton\"],\n  features: [i0.ɵɵInheritDefinitionFeature],\n  ngContentSelectors: _c2,\n  decls: 13,\n  vars: 20,\n  consts: [[1, \"mat-radio-label\"], [\"label\", \"\"], [1, \"mat-radio-container\"], [1, \"mat-radio-outer-circle\"], [1, \"mat-radio-inner-circle\"], [\"type\", \"radio\", 1, \"mat-radio-input\", \"cdk-visually-hidden\", 3, \"id\", \"checked\", \"disabled\", \"tabIndex\", \"required\", \"change\", \"click\"], [\"input\", \"\"], [\"mat-ripple\", \"\", 1, \"mat-radio-ripple\", \"mat-focus-indicator\", 3, \"matRippleTrigger\", \"matRippleDisabled\", \"matRippleCentered\", \"matRippleRadius\", \"matRippleAnimation\"], [1, \"mat-ripple-element\", \"mat-radio-persistent-ripple\"], [1, \"mat-radio-label-content\"], [2, \"display\", \"none\"]],\n  template: function MatRadioButton_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵelementStart(0, \"label\", 0, 1)(2, \"span\", 2);\n      i0.ɵɵelement(3, \"span\", 3)(4, \"span\", 4);\n      i0.ɵɵelementStart(5, \"input\", 5, 6);\n      i0.ɵɵlistener(\"change\", function MatRadioButton_Template_input_change_5_listener($event) {\n        return ctx._onInputInteraction($event);\n      })(\"click\", function MatRadioButton_Template_input_click_5_listener($event) {\n        return ctx._onInputClick($event);\n      });\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(7, \"span\", 7);\n      i0.ɵɵelement(8, \"span\", 8);\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(9, \"span\", 9)(10, \"span\", 10);\n      i0.ɵɵtext(11, \"\\xA0\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵprojection(12);\n      i0.ɵɵelementEnd()();\n    }\n\n    if (rf & 2) {\n      const _r0 = i0.ɵɵreference(1);\n\n      i0.ɵɵattribute(\"for\", ctx.inputId);\n      i0.ɵɵadvance(5);\n      i0.ɵɵproperty(\"id\", ctx.inputId)(\"checked\", ctx.checked)(\"disabled\", ctx.disabled)(\"tabIndex\", ctx.tabIndex)(\"required\", ctx.required);\n      i0.ɵɵattribute(\"name\", ctx.name)(\"value\", ctx.value)(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledby)(\"aria-describedby\", ctx.ariaDescribedby);\n      i0.ɵɵadvance(2);\n      i0.ɵɵproperty(\"matRippleTrigger\", _r0)(\"matRippleDisabled\", ctx._isRippleDisabled())(\"matRippleCentered\", true)(\"matRippleRadius\", 20)(\"matRippleAnimation\", i0.ɵɵpureFunction1(18, _c1, ctx._noopAnimations ? 0 : 150));\n      i0.ɵɵadvance(2);\n      i0.ɵɵclassProp(\"mat-radio-label-before\", ctx.labelPosition == \"before\");\n    }\n  },\n  dependencies: [i3.MatRipple],\n  styles: [\".mat-radio-button{display:inline-block;-webkit-tap-highlight-color:transparent;outline:0}.mat-radio-label{-webkit-user-select:none;-moz-user-select:none;user-select:none;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle;width:100%}.mat-radio-container{box-sizing:border-box;display:inline-block;position:relative;width:20px;height:20px;flex-shrink:0}.mat-radio-outer-circle{box-sizing:border-box;display:block;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}._mat-animation-noopable .mat-radio-outer-circle{transition:none}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;display:block;height:20px;left:0;position:absolute;top:0;opacity:0;transition:transform ease 280ms,background-color ease 280ms,opacity linear 1ms 280ms;width:20px;transform:scale(0.001);-webkit-print-color-adjust:exact;color-adjust:exact}.mat-radio-checked .mat-radio-inner-circle{transform:scale(0.5);opacity:1;transition:transform ease 280ms,background-color ease 280ms}.cdk-high-contrast-active .mat-radio-checked .mat-radio-inner-circle{border:solid 10px}._mat-animation-noopable .mat-radio-inner-circle{transition:none}.mat-radio-label-content{-webkit-user-select:auto;-moz-user-select:auto;user-select:auto;display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-button .mat-radio-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-radio-button .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple){opacity:.16}.mat-radio-persistent-ripple{width:100%;height:100%;transform:none;top:0;left:0}.mat-radio-container:hover .mat-radio-persistent-ripple{opacity:.04}.mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-persistent-ripple,.mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-persistent-ripple{opacity:.12}.mat-radio-persistent-ripple,.mat-radio-disabled .mat-radio-container:hover .mat-radio-persistent-ripple{opacity:0}@media(hover: none){.mat-radio-container:hover .mat-radio-persistent-ripple{display:none}}.mat-radio-input{bottom:0;left:50%}.cdk-high-contrast-active .mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-ripple,.cdk-high-contrast-active .mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-ripple{outline:solid 3px}.cdk-high-contrast-active .mat-radio-disabled{opacity:.5}\\n\"],\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MatRadioButton, [{\n    type: Component,\n    args: [{\n      selector: 'mat-radio-button',\n      inputs: ['disableRipple', 'tabIndex'],\n      encapsulation: ViewEncapsulation.None,\n      exportAs: 'matRadioButton',\n      host: {\n        'class': 'mat-radio-button',\n        '[class.mat-radio-checked]': 'checked',\n        '[class.mat-radio-disabled]': 'disabled',\n        '[class._mat-animation-noopable]': '_noopAnimations',\n        '[class.mat-primary]': 'color === \"primary\"',\n        '[class.mat-accent]': 'color === \"accent\"',\n        '[class.mat-warn]': 'color === \"warn\"',\n        // Needs to be removed since it causes some a11y issues (see #21266).\n        '[attr.tabindex]': 'null',\n        '[attr.id]': 'id',\n        '[attr.aria-label]': 'null',\n        '[attr.aria-labelledby]': 'null',\n        '[attr.aria-describedby]': 'null',\n        // Note: under normal conditions focus shouldn't land on this element, however it may be\n        // programmatically set, for example inside of a focus trap, in this case we want to forward\n        // the focus to the native element.\n        '(focus)': '_inputElement.nativeElement.focus()'\n      },\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: \"<!-- TODO(jelbourn): render the radio on either side of the content -->\\n<!-- TODO(mtlin): Evaluate trade-offs of using native radio vs. cost of additional bindings. -->\\n<label [attr.for]=\\\"inputId\\\" class=\\\"mat-radio-label\\\" #label>\\n  <!-- The actual 'radio' part of the control. -->\\n  <span class=\\\"mat-radio-container\\\">\\n    <span class=\\\"mat-radio-outer-circle\\\"></span>\\n    <span class=\\\"mat-radio-inner-circle\\\"></span>\\n    <input #input class=\\\"mat-radio-input cdk-visually-hidden\\\" type=\\\"radio\\\"\\n        [id]=\\\"inputId\\\"\\n        [checked]=\\\"checked\\\"\\n        [disabled]=\\\"disabled\\\"\\n        [tabIndex]=\\\"tabIndex\\\"\\n        [attr.name]=\\\"name\\\"\\n        [attr.value]=\\\"value\\\"\\n        [required]=\\\"required\\\"\\n        [attr.aria-label]=\\\"ariaLabel\\\"\\n        [attr.aria-labelledby]=\\\"ariaLabelledby\\\"\\n        [attr.aria-describedby]=\\\"ariaDescribedby\\\"\\n        (change)=\\\"_onInputInteraction($event)\\\"\\n        (click)=\\\"_onInputClick($event)\\\">\\n\\n    <!-- The ripple comes after the input so that we can target it with a CSS\\n         sibling selector when the input is focused. -->\\n    <span mat-ripple class=\\\"mat-radio-ripple mat-focus-indicator\\\"\\n         [matRippleTrigger]=\\\"label\\\"\\n         [matRippleDisabled]=\\\"_isRippleDisabled()\\\"\\n         [matRippleCentered]=\\\"true\\\"\\n         [matRippleRadius]=\\\"20\\\"\\n         [matRippleAnimation]=\\\"{enterDuration: _noopAnimations ? 0 : 150}\\\">\\n\\n      <span class=\\\"mat-ripple-element mat-radio-persistent-ripple\\\"></span>\\n    </span>\\n  </span>\\n\\n  <!-- The label content for radio control. -->\\n  <span class=\\\"mat-radio-label-content\\\" [class.mat-radio-label-before]=\\\"labelPosition == 'before'\\\">\\n    <!-- Add an invisible span so JAWS can read the label -->\\n    <span style=\\\"display:none\\\">&nbsp;</span>\\n    <ng-content></ng-content>\\n  </span>\\n</label>\\n\",\n      styles: [\".mat-radio-button{display:inline-block;-webkit-tap-highlight-color:transparent;outline:0}.mat-radio-label{-webkit-user-select:none;-moz-user-select:none;user-select:none;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle;width:100%}.mat-radio-container{box-sizing:border-box;display:inline-block;position:relative;width:20px;height:20px;flex-shrink:0}.mat-radio-outer-circle{box-sizing:border-box;display:block;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}._mat-animation-noopable .mat-radio-outer-circle{transition:none}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;display:block;height:20px;left:0;position:absolute;top:0;opacity:0;transition:transform ease 280ms,background-color ease 280ms,opacity linear 1ms 280ms;width:20px;transform:scale(0.001);-webkit-print-color-adjust:exact;color-adjust:exact}.mat-radio-checked .mat-radio-inner-circle{transform:scale(0.5);opacity:1;transition:transform ease 280ms,background-color ease 280ms}.cdk-high-contrast-active .mat-radio-checked .mat-radio-inner-circle{border:solid 10px}._mat-animation-noopable .mat-radio-inner-circle{transition:none}.mat-radio-label-content{-webkit-user-select:auto;-moz-user-select:auto;user-select:auto;display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-button .mat-radio-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-radio-button .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple){opacity:.16}.mat-radio-persistent-ripple{width:100%;height:100%;transform:none;top:0;left:0}.mat-radio-container:hover .mat-radio-persistent-ripple{opacity:.04}.mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-persistent-ripple,.mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-persistent-ripple{opacity:.12}.mat-radio-persistent-ripple,.mat-radio-disabled .mat-radio-container:hover .mat-radio-persistent-ripple{opacity:0}@media(hover: none){.mat-radio-container:hover .mat-radio-persistent-ripple{display:none}}.mat-radio-input{bottom:0;left:50%}.cdk-high-contrast-active .mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-ripple,.cdk-high-contrast-active .mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-ripple{outline:solid 3px}.cdk-high-contrast-active .mat-radio-disabled{opacity:.5}\\n\"]\n    }]\n  }], function () {\n    return [{\n      type: MatRadioGroup,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [MAT_RADIO_GROUP]\n      }]\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i1.FocusMonitor\n    }, {\n      type: i2.UniqueSelectionDispatcher\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [ANIMATION_MODULE_TYPE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [MAT_RADIO_DEFAULT_OPTIONS]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Attribute,\n        args: ['tabindex']\n      }]\n    }];\n  }, null);\n})();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nclass MatRadioModule {}\n\nMatRadioModule.ɵfac = function MatRadioModule_Factory(t) {\n  return new (t || MatRadioModule)();\n};\n\nMatRadioModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: MatRadioModule\n});\nMatRadioModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[MatRippleModule, MatCommonModule], MatCommonModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MatRadioModule, [{\n    type: NgModule,\n    args: [{\n      imports: [MatRippleModule, MatCommonModule],\n      exports: [MatRadioGroup, MatRadioButton, MatCommonModule],\n      declarations: [MatRadioGroup, MatRadioButton]\n    }]\n  }], null, null);\n})();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { MAT_RADIO_DEFAULT_OPTIONS, MAT_RADIO_DEFAULT_OPTIONS_FACTORY, MAT_RADIO_GROUP, MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, MatRadioButton, MatRadioChange, MatRadioGroup, MatRadioModule, _MatRadioButtonBase, _MatRadioGroupBase };","map":{"version":3,"names":["i0","InjectionToken","forwardRef","EventEmitter","Directive","Output","Input","ContentChildren","ViewChild","Component","ViewEncapsulation","ChangeDetectionStrategy","Optional","Inject","Attribute","NgModule","i3","mixinDisableRipple","mixinTabIndex","MatRippleModule","MatCommonModule","i1","coerceBooleanProperty","coerceNumberProperty","i2","NG_VALUE_ACCESSOR","ANIMATION_MODULE_TYPE","MAT_RADIO_DEFAULT_OPTIONS","providedIn","factory","MAT_RADIO_DEFAULT_OPTIONS_FACTORY","color","nextUniqueId","MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR","provide","useExisting","MatRadioGroup","multi","MatRadioChange","constructor","source","value","MAT_RADIO_GROUP","_MatRadioGroupBase","_changeDetector","_value","_name","_selected","_isInitialized","_labelPosition","_disabled","_required","_controlValueAccessorChangeFn","onTouched","change","name","_updateRadioButtonNames","labelPosition","v","_markRadiosForCheck","newValue","_updateSelectedRadioFromValue","_checkSelectedRadioButton","checked","selected","disabled","required","ngAfterContentInit","_touch","_radios","forEach","radio","_markForCheck","isAlreadySelected","_emitChangeEvent","emit","writeValue","markForCheck","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","ɵfac","ChangeDetectorRef","ɵdir","type","MatRadioButton","args","selector","exportAs","providers","host","descendants","MatRadioButtonBase","_elementRef","_MatRadioButtonMixinBase","_MatRadioButtonBase","radioGroup","elementRef","_focusMonitor","_radioDispatcher","animationMode","_providerOverride","tabIndex","_uniqueId","id","_checked","_removeUniqueSelectionListener","_noopAnimations","listen","newCheckedState","notify","_setDisabled","_color","inputId","focus","options","origin","focusVia","_inputElement","nativeElement","ngOnInit","ngAfterViewInit","monitor","subscribe","focusOrigin","ngOnDestroy","stopMonitoring","_isRippleDisabled","disableRipple","_onInputClick","event","stopPropagation","_onInputInteraction","groupValueChanged","ElementRef","FocusMonitor","UniqueSelectionDispatcher","undefined","ariaLabel","ariaLabelledby","ariaDescribedby","changeDetector","focusMonitor","radioDispatcher","providerOverride","ɵcmp","MatRipple","inputs","encapsulation","None","changeDetection","OnPush","template","styles","decorators","MatRadioModule","ɵmod","ɵinj","imports","exports","declarations"],"sources":["C:/Users/mary-/OneDrive/Documents/MIAGE DAUPHINE/Dauphine S9/Dev Front Back End/final-version/front/node_modules/@angular/material/fesm2020/radio.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\r\nimport { InjectionToken, forwardRef, EventEmitter, Directive, Output, Input, ContentChildren, ViewChild, Component, ViewEncapsulation, ChangeDetectionStrategy, Optional, Inject, Attribute, NgModule } from '@angular/core';\r\nimport * as i3 from '@angular/material/core';\r\nimport { mixinDisableRipple, mixinTabIndex, MatRippleModule, MatCommonModule } from '@angular/material/core';\r\nimport * as i1 from '@angular/cdk/a11y';\r\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\r\nimport * as i2 from '@angular/cdk/collections';\r\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\r\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst MAT_RADIO_DEFAULT_OPTIONS = new InjectionToken('mat-radio-default-options', {\r\n    providedIn: 'root',\r\n    factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY,\r\n});\r\nfunction MAT_RADIO_DEFAULT_OPTIONS_FACTORY() {\r\n    return {\r\n        color: 'accent',\r\n    };\r\n}\r\n// Increasing integer for generating unique ids for radio components.\r\nlet nextUniqueId = 0;\r\n/**\r\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\r\n * allows it to support [(ngModel)] and ngControl.\r\n * @docs-private\r\n */\r\nconst MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {\r\n    provide: NG_VALUE_ACCESSOR,\r\n    useExisting: forwardRef(() => MatRadioGroup),\r\n    multi: true,\r\n};\r\n/** Change event object emitted by MatRadio and MatRadioGroup. */\r\nclass MatRadioChange {\r\n    constructor(\r\n    /** The MatRadioButton that emits the change event. */\r\n    source, \r\n    /** The value of the MatRadioButton. */\r\n    value) {\r\n        this.source = source;\r\n        this.value = value;\r\n    }\r\n}\r\n/**\r\n * Injection token that can be used to inject instances of `MatRadioGroup`. It serves as\r\n * alternative token to the actual `MatRadioGroup` class which could cause unnecessary\r\n * retention of the class and its component metadata.\r\n */\r\nconst MAT_RADIO_GROUP = new InjectionToken('MatRadioGroup');\r\n/**\r\n * Base class with all of the `MatRadioGroup` functionality.\r\n * @docs-private\r\n */\r\nclass _MatRadioGroupBase {\r\n    constructor(_changeDetector) {\r\n        this._changeDetector = _changeDetector;\r\n        /** Selected value for the radio group. */\r\n        this._value = null;\r\n        /** The HTML name attribute applied to radio buttons in this group. */\r\n        this._name = `mat-radio-group-${nextUniqueId++}`;\r\n        /** The currently selected radio button. Should match value. */\r\n        this._selected = null;\r\n        /** Whether the `value` has been set to its initial value. */\r\n        this._isInitialized = false;\r\n        /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\r\n        this._labelPosition = 'after';\r\n        /** Whether the radio group is disabled. */\r\n        this._disabled = false;\r\n        /** Whether the radio group is required. */\r\n        this._required = false;\r\n        /** The method to be called in order to update ngModel */\r\n        this._controlValueAccessorChangeFn = () => { };\r\n        /**\r\n         * onTouch function registered via registerOnTouch (ControlValueAccessor).\r\n         * @docs-private\r\n         */\r\n        this.onTouched = () => { };\r\n        /**\r\n         * Event emitted when the group value changes.\r\n         * Change events are only emitted when the value changes due to user interaction with\r\n         * a radio button (the same behavior as `<input type-\"radio\">`).\r\n         */\r\n        this.change = new EventEmitter();\r\n    }\r\n    /** Name of the radio button group. All radio buttons inside this group will use this name. */\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    set name(value) {\r\n        this._name = value;\r\n        this._updateRadioButtonNames();\r\n    }\r\n    /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\r\n    get labelPosition() {\r\n        return this._labelPosition;\r\n    }\r\n    set labelPosition(v) {\r\n        this._labelPosition = v === 'before' ? 'before' : 'after';\r\n        this._markRadiosForCheck();\r\n    }\r\n    /**\r\n     * Value for the radio-group. Should equal the value of the selected radio button if there is\r\n     * a corresponding radio button with a matching value. If there is not such a corresponding\r\n     * radio button, this value persists to be applied in case a new radio button is added with a\r\n     * matching value.\r\n     */\r\n    get value() {\r\n        return this._value;\r\n    }\r\n    set value(newValue) {\r\n        if (this._value !== newValue) {\r\n            // Set this before proceeding to ensure no circular loop occurs with selection.\r\n            this._value = newValue;\r\n            this._updateSelectedRadioFromValue();\r\n            this._checkSelectedRadioButton();\r\n        }\r\n    }\r\n    _checkSelectedRadioButton() {\r\n        if (this._selected && !this._selected.checked) {\r\n            this._selected.checked = true;\r\n        }\r\n    }\r\n    /**\r\n     * The currently selected radio button. If set to a new radio button, the radio group value\r\n     * will be updated to match the new selected button.\r\n     */\r\n    get selected() {\r\n        return this._selected;\r\n    }\r\n    set selected(selected) {\r\n        this._selected = selected;\r\n        this.value = selected ? selected.value : null;\r\n        this._checkSelectedRadioButton();\r\n    }\r\n    /** Whether the radio group is disabled */\r\n    get disabled() {\r\n        return this._disabled;\r\n    }\r\n    set disabled(value) {\r\n        this._disabled = coerceBooleanProperty(value);\r\n        this._markRadiosForCheck();\r\n    }\r\n    /** Whether the radio group is required */\r\n    get required() {\r\n        return this._required;\r\n    }\r\n    set required(value) {\r\n        this._required = coerceBooleanProperty(value);\r\n        this._markRadiosForCheck();\r\n    }\r\n    /**\r\n     * Initialize properties once content children are available.\r\n     * This allows us to propagate relevant attributes to associated buttons.\r\n     */\r\n    ngAfterContentInit() {\r\n        // Mark this component as initialized in AfterContentInit because the initial value can\r\n        // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\r\n        // NgModel occurs *after* the OnInit of the MatRadioGroup.\r\n        this._isInitialized = true;\r\n    }\r\n    /**\r\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\r\n     * radio buttons upon their blur.\r\n     */\r\n    _touch() {\r\n        if (this.onTouched) {\r\n            this.onTouched();\r\n        }\r\n    }\r\n    _updateRadioButtonNames() {\r\n        if (this._radios) {\r\n            this._radios.forEach(radio => {\r\n                radio.name = this.name;\r\n                radio._markForCheck();\r\n            });\r\n        }\r\n    }\r\n    /** Updates the `selected` radio button from the internal _value state. */\r\n    _updateSelectedRadioFromValue() {\r\n        // If the value already matches the selected radio, do nothing.\r\n        const isAlreadySelected = this._selected !== null && this._selected.value === this._value;\r\n        if (this._radios && !isAlreadySelected) {\r\n            this._selected = null;\r\n            this._radios.forEach(radio => {\r\n                radio.checked = this.value === radio.value;\r\n                if (radio.checked) {\r\n                    this._selected = radio;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /** Dispatch change event with current selection and group value. */\r\n    _emitChangeEvent() {\r\n        if (this._isInitialized) {\r\n            this.change.emit(new MatRadioChange(this._selected, this._value));\r\n        }\r\n    }\r\n    _markRadiosForCheck() {\r\n        if (this._radios) {\r\n            this._radios.forEach(radio => radio._markForCheck());\r\n        }\r\n    }\r\n    /**\r\n     * Sets the model value. Implemented as part of ControlValueAccessor.\r\n     * @param value\r\n     */\r\n    writeValue(value) {\r\n        this.value = value;\r\n        this._changeDetector.markForCheck();\r\n    }\r\n    /**\r\n     * Registers a callback to be triggered when the model value changes.\r\n     * Implemented as part of ControlValueAccessor.\r\n     * @param fn Callback to be registered.\r\n     */\r\n    registerOnChange(fn) {\r\n        this._controlValueAccessorChangeFn = fn;\r\n    }\r\n    /**\r\n     * Registers a callback to be triggered when the control is touched.\r\n     * Implemented as part of ControlValueAccessor.\r\n     * @param fn Callback to be registered.\r\n     */\r\n    registerOnTouched(fn) {\r\n        this.onTouched = fn;\r\n    }\r\n    /**\r\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\r\n     * @param isDisabled Whether the control should be disabled.\r\n     */\r\n    setDisabledState(isDisabled) {\r\n        this.disabled = isDisabled;\r\n        this._changeDetector.markForCheck();\r\n    }\r\n}\r\n_MatRadioGroupBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", ngImport: i0, type: _MatRadioGroupBase, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });\r\n_MatRadioGroupBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", type: _MatRadioGroupBase, inputs: { color: \"color\", name: \"name\", labelPosition: \"labelPosition\", value: \"value\", selected: \"selected\", disabled: \"disabled\", required: \"required\" }, outputs: { change: \"change\" }, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", ngImport: i0, type: _MatRadioGroupBase, decorators: [{\r\n            type: Directive\r\n        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { change: [{\r\n                type: Output\r\n            }], color: [{\r\n                type: Input\r\n            }], name: [{\r\n                type: Input\r\n            }], labelPosition: [{\r\n                type: Input\r\n            }], value: [{\r\n                type: Input\r\n            }], selected: [{\r\n                type: Input\r\n            }], disabled: [{\r\n                type: Input\r\n            }], required: [{\r\n                type: Input\r\n            }] } });\r\n/**\r\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\r\n */\r\nclass MatRadioGroup extends _MatRadioGroupBase {\r\n}\r\nMatRadioGroup.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", ngImport: i0, type: MatRadioGroup, deps: null, target: i0.ɵɵFactoryTarget.Directive });\r\nMatRadioGroup.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", type: MatRadioGroup, selector: \"mat-radio-group\", host: { attributes: { \"role\": \"radiogroup\" }, classAttribute: \"mat-radio-group\" }, providers: [\r\n        MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR,\r\n        { provide: MAT_RADIO_GROUP, useExisting: MatRadioGroup },\r\n    ], queries: [{ propertyName: \"_radios\", predicate: MatRadioButton, descendants: true }], exportAs: [\"matRadioGroup\"], usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", ngImport: i0, type: MatRadioGroup, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: 'mat-radio-group',\r\n                    exportAs: 'matRadioGroup',\r\n                    providers: [\r\n                        MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR,\r\n                        { provide: MAT_RADIO_GROUP, useExisting: MatRadioGroup },\r\n                    ],\r\n                    host: {\r\n                        'role': 'radiogroup',\r\n                        'class': 'mat-radio-group',\r\n                    },\r\n                }]\r\n        }], propDecorators: { _radios: [{\r\n                type: ContentChildren,\r\n                args: [forwardRef(() => MatRadioButton), { descendants: true }]\r\n            }] } });\r\n// Boilerplate for applying mixins to MatRadioButton.\r\n/** @docs-private */\r\nclass MatRadioButtonBase {\r\n    constructor(_elementRef) {\r\n        this._elementRef = _elementRef;\r\n    }\r\n}\r\nconst _MatRadioButtonMixinBase = mixinDisableRipple(mixinTabIndex(MatRadioButtonBase));\r\n/**\r\n * Base class with all of the `MatRadioButton` functionality.\r\n * @docs-private\r\n */\r\nclass _MatRadioButtonBase extends _MatRadioButtonMixinBase {\r\n    constructor(radioGroup, elementRef, _changeDetector, _focusMonitor, _radioDispatcher, animationMode, _providerOverride, tabIndex) {\r\n        super(elementRef);\r\n        this._changeDetector = _changeDetector;\r\n        this._focusMonitor = _focusMonitor;\r\n        this._radioDispatcher = _radioDispatcher;\r\n        this._providerOverride = _providerOverride;\r\n        this._uniqueId = `mat-radio-${++nextUniqueId}`;\r\n        /** The unique ID for the radio button. */\r\n        this.id = this._uniqueId;\r\n        /**\r\n         * Event emitted when the checked state of this radio button changes.\r\n         * Change events are only emitted when the value changes due to user interaction with\r\n         * the radio button (the same behavior as `<input type-\"radio\">`).\r\n         */\r\n        this.change = new EventEmitter();\r\n        /** Whether this radio is checked. */\r\n        this._checked = false;\r\n        /** Value assigned to this radio. */\r\n        this._value = null;\r\n        /** Unregister function for _radioDispatcher */\r\n        this._removeUniqueSelectionListener = () => { };\r\n        // Assertions. Ideally these should be stripped out by the compiler.\r\n        // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\r\n        this.radioGroup = radioGroup;\r\n        this._noopAnimations = animationMode === 'NoopAnimations';\r\n        if (tabIndex) {\r\n            this.tabIndex = coerceNumberProperty(tabIndex, 0);\r\n        }\r\n        this._removeUniqueSelectionListener = _radioDispatcher.listen((id, name) => {\r\n            if (id !== this.id && name === this.name) {\r\n                this.checked = false;\r\n            }\r\n        });\r\n    }\r\n    /** Whether this radio button is checked. */\r\n    get checked() {\r\n        return this._checked;\r\n    }\r\n    set checked(value) {\r\n        const newCheckedState = coerceBooleanProperty(value);\r\n        if (this._checked !== newCheckedState) {\r\n            this._checked = newCheckedState;\r\n            if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\r\n                this.radioGroup.selected = this;\r\n            }\r\n            else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\r\n                // When unchecking the selected radio button, update the selected radio\r\n                // property on the group.\r\n                this.radioGroup.selected = null;\r\n            }\r\n            if (newCheckedState) {\r\n                // Notify all radio buttons with the same name to un-check.\r\n                this._radioDispatcher.notify(this.id, this.name);\r\n            }\r\n            this._changeDetector.markForCheck();\r\n        }\r\n    }\r\n    /** The value of this radio button. */\r\n    get value() {\r\n        return this._value;\r\n    }\r\n    set value(value) {\r\n        if (this._value !== value) {\r\n            this._value = value;\r\n            if (this.radioGroup !== null) {\r\n                if (!this.checked) {\r\n                    // Update checked when the value changed to match the radio group's value\r\n                    this.checked = this.radioGroup.value === value;\r\n                }\r\n                if (this.checked) {\r\n                    this.radioGroup.selected = this;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /** Whether the label should appear after or before the radio button. Defaults to 'after' */\r\n    get labelPosition() {\r\n        return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\r\n    }\r\n    set labelPosition(value) {\r\n        this._labelPosition = value;\r\n    }\r\n    /** Whether the radio button is disabled. */\r\n    get disabled() {\r\n        return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\r\n    }\r\n    set disabled(value) {\r\n        this._setDisabled(coerceBooleanProperty(value));\r\n    }\r\n    /** Whether the radio button is required. */\r\n    get required() {\r\n        return this._required || (this.radioGroup && this.radioGroup.required);\r\n    }\r\n    set required(value) {\r\n        this._required = coerceBooleanProperty(value);\r\n    }\r\n    /** Theme color of the radio button. */\r\n    get color() {\r\n        // As per Material design specifications the selection control radio should use the accent color\r\n        // palette by default. https://material.io/guidelines/components/selection-controls.html\r\n        return (this._color ||\r\n            (this.radioGroup && this.radioGroup.color) ||\r\n            (this._providerOverride && this._providerOverride.color) ||\r\n            'accent');\r\n    }\r\n    set color(newValue) {\r\n        this._color = newValue;\r\n    }\r\n    /** ID of the native input element inside `<mat-radio-button>` */\r\n    get inputId() {\r\n        return `${this.id || this._uniqueId}-input`;\r\n    }\r\n    /** Focuses the radio button. */\r\n    focus(options, origin) {\r\n        if (origin) {\r\n            this._focusMonitor.focusVia(this._inputElement, origin, options);\r\n        }\r\n        else {\r\n            this._inputElement.nativeElement.focus(options);\r\n        }\r\n    }\r\n    /**\r\n     * Marks the radio button as needing checking for change detection.\r\n     * This method is exposed because the parent radio group will directly\r\n     * update bound properties of the radio button.\r\n     */\r\n    _markForCheck() {\r\n        // When group value changes, the button will not be notified. Use `markForCheck` to explicit\r\n        // update radio button's status\r\n        this._changeDetector.markForCheck();\r\n    }\r\n    ngOnInit() {\r\n        if (this.radioGroup) {\r\n            // If the radio is inside a radio group, determine if it should be checked\r\n            this.checked = this.radioGroup.value === this._value;\r\n            if (this.checked) {\r\n                this.radioGroup.selected = this;\r\n            }\r\n            // Copy name from parent radio group\r\n            this.name = this.radioGroup.name;\r\n        }\r\n    }\r\n    ngAfterViewInit() {\r\n        this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\r\n            if (!focusOrigin && this.radioGroup) {\r\n                this.radioGroup._touch();\r\n            }\r\n        });\r\n    }\r\n    ngOnDestroy() {\r\n        this._focusMonitor.stopMonitoring(this._elementRef);\r\n        this._removeUniqueSelectionListener();\r\n    }\r\n    /** Dispatch change event with current value. */\r\n    _emitChangeEvent() {\r\n        this.change.emit(new MatRadioChange(this, this._value));\r\n    }\r\n    _isRippleDisabled() {\r\n        return this.disableRipple || this.disabled;\r\n    }\r\n    _onInputClick(event) {\r\n        // We have to stop propagation for click events on the visual hidden input element.\r\n        // By default, when a user clicks on a label element, a generated click event will be\r\n        // dispatched on the associated input element. Since we are using a label element as our\r\n        // root container, the click event on the `radio-button` will be executed twice.\r\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\r\n        // This will lead to multiple click events.\r\n        // Preventing bubbling for the second event will solve that issue.\r\n        event.stopPropagation();\r\n    }\r\n    /** Triggered when the radio button receives an interaction from the user. */\r\n    _onInputInteraction(event) {\r\n        // We always have to stop propagation on the change event.\r\n        // Otherwise the change event, from the input element, will bubble up and\r\n        // emit its event object to the `change` output.\r\n        event.stopPropagation();\r\n        if (!this.checked && !this.disabled) {\r\n            const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\r\n            this.checked = true;\r\n            this._emitChangeEvent();\r\n            if (this.radioGroup) {\r\n                this.radioGroup._controlValueAccessorChangeFn(this.value);\r\n                if (groupValueChanged) {\r\n                    this.radioGroup._emitChangeEvent();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /** Sets the disabled state and marks for check if a change occurred. */\r\n    _setDisabled(value) {\r\n        if (this._disabled !== value) {\r\n            this._disabled = value;\r\n            this._changeDetector.markForCheck();\r\n        }\r\n    }\r\n}\r\n_MatRadioButtonBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", ngImport: i0, type: _MatRadioButtonBase, deps: \"invalid\", target: i0.ɵɵFactoryTarget.Directive });\r\n_MatRadioButtonBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", type: _MatRadioButtonBase, inputs: { id: \"id\", name: \"name\", ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"], ariaDescribedby: [\"aria-describedby\", \"ariaDescribedby\"], checked: \"checked\", value: \"value\", labelPosition: \"labelPosition\", disabled: \"disabled\", required: \"required\", color: \"color\" }, outputs: { change: \"change\" }, viewQueries: [{ propertyName: \"_inputElement\", first: true, predicate: [\"input\"], descendants: true }], usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", ngImport: i0, type: _MatRadioButtonBase, decorators: [{\r\n            type: Directive\r\n        }], ctorParameters: function () { return [{ type: _MatRadioGroupBase }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i1.FocusMonitor }, { type: i2.UniqueSelectionDispatcher }, { type: undefined }, { type: undefined }, { type: undefined }]; }, propDecorators: { id: [{\r\n                type: Input\r\n            }], name: [{\r\n                type: Input\r\n            }], ariaLabel: [{\r\n                type: Input,\r\n                args: ['aria-label']\r\n            }], ariaLabelledby: [{\r\n                type: Input,\r\n                args: ['aria-labelledby']\r\n            }], ariaDescribedby: [{\r\n                type: Input,\r\n                args: ['aria-describedby']\r\n            }], checked: [{\r\n                type: Input\r\n            }], value: [{\r\n                type: Input\r\n            }], labelPosition: [{\r\n                type: Input\r\n            }], disabled: [{\r\n                type: Input\r\n            }], required: [{\r\n                type: Input\r\n            }], color: [{\r\n                type: Input\r\n            }], change: [{\r\n                type: Output\r\n            }], _inputElement: [{\r\n                type: ViewChild,\r\n                args: ['input']\r\n            }] } });\r\n/**\r\n * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.\r\n */\r\nclass MatRadioButton extends _MatRadioButtonBase {\r\n    constructor(radioGroup, elementRef, changeDetector, focusMonitor, radioDispatcher, animationMode, providerOverride, tabIndex) {\r\n        super(radioGroup, elementRef, changeDetector, focusMonitor, radioDispatcher, animationMode, providerOverride, tabIndex);\r\n    }\r\n}\r\nMatRadioButton.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", ngImport: i0, type: MatRadioButton, deps: [{ token: MAT_RADIO_GROUP, optional: true }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i1.FocusMonitor }, { token: i2.UniqueSelectionDispatcher }, { token: ANIMATION_MODULE_TYPE, optional: true }, { token: MAT_RADIO_DEFAULT_OPTIONS, optional: true }, { token: 'tabindex', attribute: true }], target: i0.ɵɵFactoryTarget.Component });\r\nMatRadioButton.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", type: MatRadioButton, selector: \"mat-radio-button\", inputs: { disableRipple: \"disableRipple\", tabIndex: \"tabIndex\" }, host: { listeners: { \"focus\": \"_inputElement.nativeElement.focus()\" }, properties: { \"class.mat-radio-checked\": \"checked\", \"class.mat-radio-disabled\": \"disabled\", \"class._mat-animation-noopable\": \"_noopAnimations\", \"class.mat-primary\": \"color === \\\"primary\\\"\", \"class.mat-accent\": \"color === \\\"accent\\\"\", \"class.mat-warn\": \"color === \\\"warn\\\"\", \"attr.tabindex\": \"null\", \"attr.id\": \"id\", \"attr.aria-label\": \"null\", \"attr.aria-labelledby\": \"null\", \"attr.aria-describedby\": \"null\" }, classAttribute: \"mat-radio-button\" }, exportAs: [\"matRadioButton\"], usesInheritance: true, ngImport: i0, template: \"<!-- TODO(jelbourn): render the radio on either side of the content -->\\n<!-- TODO(mtlin): Evaluate trade-offs of using native radio vs. cost of additional bindings. -->\\n<label [attr.for]=\\\"inputId\\\" class=\\\"mat-radio-label\\\" #label>\\n  <!-- The actual 'radio' part of the control. -->\\n  <span class=\\\"mat-radio-container\\\">\\n    <span class=\\\"mat-radio-outer-circle\\\"></span>\\n    <span class=\\\"mat-radio-inner-circle\\\"></span>\\n    <input #input class=\\\"mat-radio-input cdk-visually-hidden\\\" type=\\\"radio\\\"\\n        [id]=\\\"inputId\\\"\\n        [checked]=\\\"checked\\\"\\n        [disabled]=\\\"disabled\\\"\\n        [tabIndex]=\\\"tabIndex\\\"\\n        [attr.name]=\\\"name\\\"\\n        [attr.value]=\\\"value\\\"\\n        [required]=\\\"required\\\"\\n        [attr.aria-label]=\\\"ariaLabel\\\"\\n        [attr.aria-labelledby]=\\\"ariaLabelledby\\\"\\n        [attr.aria-describedby]=\\\"ariaDescribedby\\\"\\n        (change)=\\\"_onInputInteraction($event)\\\"\\n        (click)=\\\"_onInputClick($event)\\\">\\n\\n    <!-- The ripple comes after the input so that we can target it with a CSS\\n         sibling selector when the input is focused. -->\\n    <span mat-ripple class=\\\"mat-radio-ripple mat-focus-indicator\\\"\\n         [matRippleTrigger]=\\\"label\\\"\\n         [matRippleDisabled]=\\\"_isRippleDisabled()\\\"\\n         [matRippleCentered]=\\\"true\\\"\\n         [matRippleRadius]=\\\"20\\\"\\n         [matRippleAnimation]=\\\"{enterDuration: _noopAnimations ? 0 : 150}\\\">\\n\\n      <span class=\\\"mat-ripple-element mat-radio-persistent-ripple\\\"></span>\\n    </span>\\n  </span>\\n\\n  <!-- The label content for radio control. -->\\n  <span class=\\\"mat-radio-label-content\\\" [class.mat-radio-label-before]=\\\"labelPosition == 'before'\\\">\\n    <!-- Add an invisible span so JAWS can read the label -->\\n    <span style=\\\"display:none\\\">&nbsp;</span>\\n    <ng-content></ng-content>\\n  </span>\\n</label>\\n\", styles: [\".mat-radio-button{display:inline-block;-webkit-tap-highlight-color:transparent;outline:0}.mat-radio-label{-webkit-user-select:none;-moz-user-select:none;user-select:none;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle;width:100%}.mat-radio-container{box-sizing:border-box;display:inline-block;position:relative;width:20px;height:20px;flex-shrink:0}.mat-radio-outer-circle{box-sizing:border-box;display:block;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}._mat-animation-noopable .mat-radio-outer-circle{transition:none}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;display:block;height:20px;left:0;position:absolute;top:0;opacity:0;transition:transform ease 280ms,background-color ease 280ms,opacity linear 1ms 280ms;width:20px;transform:scale(0.001);-webkit-print-color-adjust:exact;color-adjust:exact}.mat-radio-checked .mat-radio-inner-circle{transform:scale(0.5);opacity:1;transition:transform ease 280ms,background-color ease 280ms}.cdk-high-contrast-active .mat-radio-checked .mat-radio-inner-circle{border:solid 10px}._mat-animation-noopable .mat-radio-inner-circle{transition:none}.mat-radio-label-content{-webkit-user-select:auto;-moz-user-select:auto;user-select:auto;display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-button .mat-radio-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-radio-button .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple){opacity:.16}.mat-radio-persistent-ripple{width:100%;height:100%;transform:none;top:0;left:0}.mat-radio-container:hover .mat-radio-persistent-ripple{opacity:.04}.mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-persistent-ripple,.mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-persistent-ripple{opacity:.12}.mat-radio-persistent-ripple,.mat-radio-disabled .mat-radio-container:hover .mat-radio-persistent-ripple{opacity:0}@media(hover: none){.mat-radio-container:hover .mat-radio-persistent-ripple{display:none}}.mat-radio-input{bottom:0;left:50%}.cdk-high-contrast-active .mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-ripple,.cdk-high-contrast-active .mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-ripple{outline:solid 3px}.cdk-high-contrast-active .mat-radio-disabled{opacity:.5}\\n\"], directives: [{ type: i3.MatRipple, selector: \"[mat-ripple], [matRipple]\", inputs: [\"matRippleColor\", \"matRippleUnbounded\", \"matRippleCentered\", \"matRippleRadius\", \"matRippleAnimation\", \"matRippleDisabled\", \"matRippleTrigger\"], exportAs: [\"matRipple\"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", ngImport: i0, type: MatRadioButton, decorators: [{\r\n            type: Component,\r\n            args: [{ selector: 'mat-radio-button', inputs: ['disableRipple', 'tabIndex'], encapsulation: ViewEncapsulation.None, exportAs: 'matRadioButton', host: {\r\n                        'class': 'mat-radio-button',\r\n                        '[class.mat-radio-checked]': 'checked',\r\n                        '[class.mat-radio-disabled]': 'disabled',\r\n                        '[class._mat-animation-noopable]': '_noopAnimations',\r\n                        '[class.mat-primary]': 'color === \"primary\"',\r\n                        '[class.mat-accent]': 'color === \"accent\"',\r\n                        '[class.mat-warn]': 'color === \"warn\"',\r\n                        // Needs to be removed since it causes some a11y issues (see #21266).\r\n                        '[attr.tabindex]': 'null',\r\n                        '[attr.id]': 'id',\r\n                        '[attr.aria-label]': 'null',\r\n                        '[attr.aria-labelledby]': 'null',\r\n                        '[attr.aria-describedby]': 'null',\r\n                        // Note: under normal conditions focus shouldn't land on this element, however it may be\r\n                        // programmatically set, for example inside of a focus trap, in this case we want to forward\r\n                        // the focus to the native element.\r\n                        '(focus)': '_inputElement.nativeElement.focus()',\r\n                    }, changeDetection: ChangeDetectionStrategy.OnPush, template: \"<!-- TODO(jelbourn): render the radio on either side of the content -->\\n<!-- TODO(mtlin): Evaluate trade-offs of using native radio vs. cost of additional bindings. -->\\n<label [attr.for]=\\\"inputId\\\" class=\\\"mat-radio-label\\\" #label>\\n  <!-- The actual 'radio' part of the control. -->\\n  <span class=\\\"mat-radio-container\\\">\\n    <span class=\\\"mat-radio-outer-circle\\\"></span>\\n    <span class=\\\"mat-radio-inner-circle\\\"></span>\\n    <input #input class=\\\"mat-radio-input cdk-visually-hidden\\\" type=\\\"radio\\\"\\n        [id]=\\\"inputId\\\"\\n        [checked]=\\\"checked\\\"\\n        [disabled]=\\\"disabled\\\"\\n        [tabIndex]=\\\"tabIndex\\\"\\n        [attr.name]=\\\"name\\\"\\n        [attr.value]=\\\"value\\\"\\n        [required]=\\\"required\\\"\\n        [attr.aria-label]=\\\"ariaLabel\\\"\\n        [attr.aria-labelledby]=\\\"ariaLabelledby\\\"\\n        [attr.aria-describedby]=\\\"ariaDescribedby\\\"\\n        (change)=\\\"_onInputInteraction($event)\\\"\\n        (click)=\\\"_onInputClick($event)\\\">\\n\\n    <!-- The ripple comes after the input so that we can target it with a CSS\\n         sibling selector when the input is focused. -->\\n    <span mat-ripple class=\\\"mat-radio-ripple mat-focus-indicator\\\"\\n         [matRippleTrigger]=\\\"label\\\"\\n         [matRippleDisabled]=\\\"_isRippleDisabled()\\\"\\n         [matRippleCentered]=\\\"true\\\"\\n         [matRippleRadius]=\\\"20\\\"\\n         [matRippleAnimation]=\\\"{enterDuration: _noopAnimations ? 0 : 150}\\\">\\n\\n      <span class=\\\"mat-ripple-element mat-radio-persistent-ripple\\\"></span>\\n    </span>\\n  </span>\\n\\n  <!-- The label content for radio control. -->\\n  <span class=\\\"mat-radio-label-content\\\" [class.mat-radio-label-before]=\\\"labelPosition == 'before'\\\">\\n    <!-- Add an invisible span so JAWS can read the label -->\\n    <span style=\\\"display:none\\\">&nbsp;</span>\\n    <ng-content></ng-content>\\n  </span>\\n</label>\\n\", styles: [\".mat-radio-button{display:inline-block;-webkit-tap-highlight-color:transparent;outline:0}.mat-radio-label{-webkit-user-select:none;-moz-user-select:none;user-select:none;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle;width:100%}.mat-radio-container{box-sizing:border-box;display:inline-block;position:relative;width:20px;height:20px;flex-shrink:0}.mat-radio-outer-circle{box-sizing:border-box;display:block;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}._mat-animation-noopable .mat-radio-outer-circle{transition:none}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;display:block;height:20px;left:0;position:absolute;top:0;opacity:0;transition:transform ease 280ms,background-color ease 280ms,opacity linear 1ms 280ms;width:20px;transform:scale(0.001);-webkit-print-color-adjust:exact;color-adjust:exact}.mat-radio-checked .mat-radio-inner-circle{transform:scale(0.5);opacity:1;transition:transform ease 280ms,background-color ease 280ms}.cdk-high-contrast-active .mat-radio-checked .mat-radio-inner-circle{border:solid 10px}._mat-animation-noopable .mat-radio-inner-circle{transition:none}.mat-radio-label-content{-webkit-user-select:auto;-moz-user-select:auto;user-select:auto;display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-button .mat-radio-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-radio-button .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple){opacity:.16}.mat-radio-persistent-ripple{width:100%;height:100%;transform:none;top:0;left:0}.mat-radio-container:hover .mat-radio-persistent-ripple{opacity:.04}.mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-persistent-ripple,.mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-persistent-ripple{opacity:.12}.mat-radio-persistent-ripple,.mat-radio-disabled .mat-radio-container:hover .mat-radio-persistent-ripple{opacity:0}@media(hover: none){.mat-radio-container:hover .mat-radio-persistent-ripple{display:none}}.mat-radio-input{bottom:0;left:50%}.cdk-high-contrast-active .mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-ripple,.cdk-high-contrast-active .mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-ripple{outline:solid 3px}.cdk-high-contrast-active .mat-radio-disabled{opacity:.5}\\n\"] }]\r\n        }], ctorParameters: function () { return [{ type: MatRadioGroup, decorators: [{\r\n                    type: Optional\r\n                }, {\r\n                    type: Inject,\r\n                    args: [MAT_RADIO_GROUP]\r\n                }] }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i1.FocusMonitor }, { type: i2.UniqueSelectionDispatcher }, { type: undefined, decorators: [{\r\n                    type: Optional\r\n                }, {\r\n                    type: Inject,\r\n                    args: [ANIMATION_MODULE_TYPE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Optional\r\n                }, {\r\n                    type: Inject,\r\n                    args: [MAT_RADIO_DEFAULT_OPTIONS]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Attribute,\r\n                    args: ['tabindex']\r\n                }] }]; } });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass MatRadioModule {\r\n}\r\nMatRadioModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", ngImport: i0, type: MatRadioModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nMatRadioModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", ngImport: i0, type: MatRadioModule, declarations: [MatRadioGroup, MatRadioButton], imports: [MatRippleModule, MatCommonModule], exports: [MatRadioGroup, MatRadioButton, MatCommonModule] });\r\nMatRadioModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", ngImport: i0, type: MatRadioModule, imports: [[MatRippleModule, MatCommonModule], MatCommonModule] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0-rc.3\", ngImport: i0, type: MatRadioModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [MatRippleModule, MatCommonModule],\r\n                    exports: [MatRadioGroup, MatRadioButton, MatCommonModule],\r\n                    declarations: [MatRadioGroup, MatRadioButton],\r\n                }]\r\n        }] });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { MAT_RADIO_DEFAULT_OPTIONS, MAT_RADIO_DEFAULT_OPTIONS_FACTORY, MAT_RADIO_GROUP, MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, MatRadioButton, MatRadioChange, MatRadioGroup, MatRadioModule, _MatRadioButtonBase, _MatRadioGroupBase };\r\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}